\chapter{Die VM von Consize: Der Kernel}
\label{Sec:ConsizeVM}

In diesem Kapitel geht es um den Kern von Consize, um die \href{http://de.wikipedia.org/wiki/Virtuelle_Maschine}{Virtuelle Maschine} (VM), die aus dem eigentlichen Interpreter und einer Laufzeitumgebung besteht.

Die Consize-VM besteht aus einem Mapping mit rund 50 atomaren Wör\-tern. Da die Schlüsselwerte des Mappings allesamt Wörter sind, nennen wir das Mapping "`Wörterbuch"' (\emph{dictionary}). Jedes dieser Wörter ist mit einer Funktion assoziiert. Einzig in vier Ausnahmefällen sind die Funktionen in Stapeln eingepackt.

Grundsätzlich nimmt jede Funktion einen Stapel als Input entgegen und liefert einen Stapel als Ergebnis zurück. Darum bezeichnet man konkatenative Sprachen auch gerne als "`stapelverarbeitende Sprachen"'. Streng genommen muss eine konkatenative Sprache nicht unbedingt aus stapelverarbeitenden Funktionen aufgebaut sein.

Der eigentliche \href{http://de.wikipedia.org/wiki/Interpreter}{Interpreter} wird durch die mit dem Wort \verb|stepcc| abgebildete Funktion realisiert. Das Wort ist der Dreh- und Angelpunkt der Virtuellen Maschine und ist zentral für das Verständnis des Interpreters. Dazu kommen noch die vier erwähnten Sonderfälle, die in Stapeln verpackten Funktionen zu den Wörtern \verb|call/cc|, \verb|continue|, \verb|get-dict|, \verb|set-dict|. Diese vier Funktionen ergänzen die Fähigkeit zur \href{http://de.wikipedia.org/wiki/Metaprogrammierung}{Metaprogrammierung}.
%Zusammen mit \verb|stepcc| stellen diese fünf Wörter bzw. Funktionen den eigentlichen Antriebsmotor der Virtuellen Maschine dar. Diese Maschinerie erwartet als "`Sprit"' einen Stapel auf dem sich zwei Stapel und ein Wörterbuch befinden -- dann läuft der virtuelle Rechenmotor rund. Die zwei Stapel haben Sie in Kap.~\ref{Sec:DataCallStack} unter den Namen Callstack und Datastack kennengelernt.

Die übrigen Wörter der VM samt ihrer Funktionen bilden die \href{http://de.wikipedia.org/wiki/Laufzeitumgebung}{Laufzeitumgebung} ab, die nötig ist für den Umgang mit den fünf von Consize unterstützten Datentypen, für Ein- und Ausgabeoperationen, für arithmetische Operationen und für das Lesen und Zerlegen eines Consize-Programms. Wenn man wollte, könnte die Consize-VM mit deutlich weniger atomaren Wörtern und Funktionen auskommen. Darunter würde allerdings die Anschaulichkeit leiden, teils auch die Effizienz in der Aus\-füh\-rung. Die hier vorgestellte VM versucht eine goldene Mitte zu finden. Einerseits ist es sehr komfortabel, Stapel und Mappings als Datenstrukturen fertig zur Verfügung zu haben. Andererseits fehlt damit der Einblick, wie solche Datenstrukturen intern aufgebaut sind und funktionieren.

Eines ist in dem Zusammenhang wichtig zu erwähnen: Alle Datentypen in Consize sind immutabel (unveränderlich). Kap.~\ref{Sec:GleichheitIdentitaet} geht darauf näher ein. 

% Die Consize-VM ist in diesem Kapitel positiv spezifiziert. Damit ist gemeint: In der Spezifikation steht das Verhalten eines Wortes beschrieben, wenn man es unter den genannten Voraussetzungen verwendet. Hält man sich nicht an die Vereinbarungen, dann ist Consize frei gestellt, wie es mit der Verletzung der Vereinbarung umgehen möchte. In der Regel versucht Consize, einen Fehler durch Ablage des Wortes \verb|error| auf dem Callstack anzuzeigen.

Die Spezifikation der Consize-VM gibt pro Wort in der Regel ein Beispiel zur Verwendung des Wortes an. Die Beispiele setzen die geladene Prelude voraus, mit der Consize in aller Regel aufgerufen wird.

\section{Kurzdokumentation mittels Stapeleffekten}

Die mit den Wörtern der Virtuellen Maschine assoziierten Funktionen verarbeiten Stapel. Jede Funktion erwartet einen Stapel als Argument und liefert einen Stapel als Ergebnis zurück. Die Funktionen unterscheiden sich darin, wie viele Elemente sie auf dem Eingangsstapel mindestens erwarten und von welchem Typ die Elemente sein müssen. Vom Ergebnis her interessiert, was sich im Vergleich zum Eingangsstapel auf dem Ausgangsstapel verändert hat.

Mit Hilfe des Stapeleffektes (\emph{stack effect}) beschreibt man genau dieses Verhältnis von Erwartungen an den Eingangsstapel und den Auswirkungen auf den Ausgangsstapel. Der Stapeleffekt wird in runden Klammern notiert. Links vom Doppelstrich "`\verb|--|"' steht, was auf dem Eingangsstapel erwartet wird, rechts vom Doppelstrich steht, was der Ausgangsstapel liefert, sofern die Erwartungen an den Eingangsstapel erfüllt sind. Die Angaben für die Stapel sind von rechts nach links zu lesen, sprich, rechts ist das jeweilige obere Ende des Eingangs- bzw. Ausgangsstapels.

Ein Beispiel: Für das atomare Wort \verb|swap| gibt \verb|( x y -- y x )| den Stapeleffekt an. Damit ist gemeint: Auf dem Eingangsstapel müssen sich mindestens zwei Elemente befinden, wobei wir das oberste Element mit \verb|y| und das darauf folgende mit \verb|x| bezeichnen. Auf dem Ausgangsstapel bleiben all die nicht weiter benamten Elemente erhalten. Sie werden ergänzt um das mit \verb|y| und -- ganz zuoberst auf dem Stapel -- um das mit \verb|x| bezeichnete Element aus dem Eingangsstapel. Kurzum: \verb|swap| tauscht die obersten beiden Elemente auf dem Stapel.

%\begin{verbatim}
%> clear x y z swap
%x z y
%\end{verbatim}

%Lassen Sie sich nicht von den Werten auf dem Stapel verwirren, es sind zufällig \verb|x|, \verb|y| und \verb|z|. Der Stapeleffekt nutzt Bezeichner, die einem Menschen helfen, die Veränderungen auf den Stapelpositionen zu erfassen. Es ist wie ein Schnappschuss der erwarteten Situation auf dem Stapel vor dem Anruf eines Wortes und der Situation danach.

Es ist gar nicht so selten, dass sich auf dem Stapel ein oder mehrere Stapel befinden. Wollen wir uns bei der Angabe des Stapeleffekt auf den Inhalt eines Stapels beziehen, so notieren wir den Stapel in bekannter Notation mit eckigen Klammern und arbeiten ebenso mit Bezeichnern auf den Stapelpositionen. Vergessen Sie nicht, dass bei eckigen Klammern das obere Stapelende \emph{immer} links ist. Um die übrigen Elemente eines Stapels zu fassen, arbeiten wir mit dem \verb|&|-Zeichen als Rest-Erkenner. Das heißt: \verb|[ x y ]| meint einen Stapel mit genau zwei Elementen, dessen obersten Wert wir mit \verb|x| und den folgenden Wert mit \verb|y| bezeichnen. \verb|[ x & r ]| bezieht sich auf einen Stapel der mindestens ein Element hat. Den obersten Wert bezeichnen wir mit \verb|x|, alle restlichen Elemente des Stapels bezeichnen wir mit \verb|r|. \verb|[ x y & r ]| erwartet einen Stapel mit mindestens zwei Elementen. \verb|[ & r ]| spezifiziert einen Stapel mit beliebig vielen Elementen, die allesamt durch \verb|r| erfasst sind. Wir machen von solchen Beschreibungen zu Stapeleffekten z.B. in Kap.~\ref{sec:core.stacks} und Kap.~\ref{sec:core.meta} Gebrauch.

Obwohl die Notation für Stapeleffekte ansonsten informell ist, folgt sie gewissen Vereinbarungen. Meist sind die Namen nach einem der möglichen Datentypen benannt.

\begin{itemize}
\marginpar{Konventionen:}
\item Wenn die Implementierung als Stapel nicht entscheidend ist, reden wir auch vom Stapel mit seinen Elementen als "`Folge"' oder "`Sequenz"' (\emph{sequence}); bei der Notation der Stapeleffekte wird dann oft das Kürzel \verb|seq| verwendet.
\item Repräsentiert ein Stapel ein Programm, dann sprechen wir von einer "`Quotierung"' (\emph{quotation}), abgekürzt in den Stapeleffekten als \verb|quot|.
\item Ein Mapping kürzen wir mit \verb|map| ab, den Spezialfall eines Wör\-ter\-buchs (\emph{dictionary}) mit \verb|dict|. 
\item Handelt es sich um ein beliebiges Element (\emph{item}), dann kürzen wir es in den Stapeleffekten als \verb|itm| ab oder geben ihm einen generischen Namen wie z.B. \verb|x|, \verb|y| oder \verb|z|.
\end{itemize}

Nicht immer passen diese Konventionen, manchmal erweisen sich andere Namen als hilfreicher, die Funktion eines Wortes zu erfassen.
% Die Erläuterungen helfen Ihnen zu verstehen, was gemeint ist.

\section{Stack Shuffler: \texttt{dup}, \texttt{swap}, \texttt{drop}, \texttt{rot}}

Das Tauschen, Verschieben, Duplizieren und Entfernen von Elementen auf dem Eingangsstapel wird als \emph{stack shuffling} bezeichnet. Ganze vier Wörter dienen dazu, jedes gewünschte Arrangement der obersten drei Elemente auf dem Datastack herzustellen.

\begin{description}
\item[\texttt{dup ( x -- x x )}] dupliziert das oberste Element auf dem Stapel.
\end{description}

\begin{verbatim}
> clear x y z dup
x y z z
\end{verbatim}

\begin{description}
\item[\texttt{swap ( x y -- y x )}] vertauscht die obersten Elemente auf dem Stapel.
\end{description}

\begin{verbatim}
> clear x y z swap
x z y
\end{verbatim}

\begin{description}
\item[\texttt{drop ( x -- )}] entfernt das oberste Element auf dem Stapel.
\end{description}

\begin{verbatim}
> clear x y z drop
x y
\end{verbatim}

\begin{description}
\item[\texttt{rot ( x y z -- y z x )}] rotiert die obersten drei Elemente auf dem Stapel, wobei das dritt\-oberste Element nach ganz oben gebracht wird.
\end{description}

\begin{verbatim}
> clear x y z rot
y z x
\end{verbatim}

Die Stack Shuffler zum Rearrangieren, Duplizieren und Entfernen von Elementen des Eingangsstapels sind unverzichtbar, da Consize nicht das Konzept der \href{http://de.wikipedia.org/wiki/Variable_(Programmierung)}{Variable} kennt. Kombinatoren sind ein anderer, eleganter Weg, wie man ohne Variablen auszukommen vermag, siehe Kap.~\ref{Sec:Kombinatoren}.

% dup verhält sich referentiell transparent

\section{Typ und Vergleich: \texttt{type}, \texttt{equal?}, \texttt{identical?}}

Consize kennt insgesamt fünf immutable Datentypen. Ein Datentyp repräsentiert eine Menge von Datenwerten. So steht der Datentyp \verb|wrd| für die Menge aller Wörter, \verb|fct| für die Menge aller Funktionen, \verb|stk| für die Menge aller Stapel und \verb|map| für die Menge aller Mappings. Eine Sonderstellung nimmt der Typ \verb|nil| ein. Er repräsentiert einen einzigen Wert, der "`Nichts"' heißt (englisch \emph{nil}) und dann eingesetzt wird, wenn statt eines Fehlers das Resultat einer Operation als erfolglos ausgewiesen werden soll im Sinne von "`es ist `nichts' dabei herumgekommen"'.
% Mehr dazu in Kap.~\ref{Sec:GleichheitIdentitaet}.

\begin{description}
\item[\texttt{type ( itm -- wrd )}] ermittelt den Datentypen des obersten Elements auf dem Stack. Der Typ ist entweder das Wort \verb|wrd|, \verb|stk|, \verb|map|, \verb|fct| oder \verb|nil|.
\end{description}

\begin{verbatim}
> clear hi type
wrd
> [ 1 2 3 ] type
wrd stk
\end{verbatim}

Sie haben ein intuitives Verständnis davon, was Gleichheit (\emph{equality}) von Werten bedeutet. Dass die Stapel \verb|[ 1 x 2 ]| und \verb|[ 1 x 2 ]| gleich sind, leuchtet Ihnen unmittelbar ein. Wir werden in Kap.~\ref{Sec:GleichheitIdentitaet} genauer definieren, was mit Gleichheit gemeint ist. In dem Kap.~\ref{Sec:GleichheitIdentitaet} wird auch das Konzept der Identität (\emph{identity}) ausführlich zur Sprache kommen. 

\begin{description}
\item[\texttt{equal? ( itm1 itm2 -- t/f )}] testet die Gleichheit der obersten beiden Stapelwerte; liefert entweder \verb|t| (für \emph{true}, wahr) oder \verb|f| (für \emph{false}, falsch) zurück.
\end{description}

\begin{verbatim}
> clear [ 1 2 3 ] [ 1 2 3 ] equal?
t
\end{verbatim}

Das Wort \verb|identical?| ist einzig aus didaktischen Gründen in Consize vorhanden, siehe Kap.~\ref{Sec:GleichheitIdentitaet}. Es hat in einer funktionalen Sprache keine Verwendung und ist in einer Consize-Implementierung nicht erforderlich.

\begin{description}
\item[\texttt{identical? ( itm1 itm2 -- t/f )}] testet die obersten zwei Stapelwerte auf Identität. Legt \verb|t| oder \verb|f| auf dem Ergebnisstapel ab.
\end{description}

Wörter, die als Ergebnis auf dem Rückgabestapel entweder ein \verb|t| (für \emph{true}) oder \verb|f| (für \emph{false}) zurücklassen, sind meist als Prädikate (ein Begriff aus der \href{http://de.wikipedia.org/wiki/Pr\%C3\%A4dikatenlogik}{Prädikatenlogik}) zu verstehen und schließen ihren Namen gerne mit einem Fragezeichen ab. In vielen Fällen ist diese Konvention hilfreich und dient als Gedächtnisstütze: Endet ein Wort mit einem Fragezeichen, ist das Resultat auf dem Stapel entweder \verb|t| oder \verb|f|.

\section{Stapel: \texttt{emptystack}, \texttt{push}, \texttt{top}, \texttt{pop}, \texttt{reverse}, \texttt{concat}}
\label{sec:core.stacks}

Der Stapel ist \emph{die} allgegenwärtige Datenstruktur in Consize.
Nicht nur bilden die Funktionen aller primitiven Wörter einen Eingangsstapel auf einen Ausgangsstapel ab. Man kann auch Stapel mit den Konstruktoren \verb|emptystack| und \verb|push| erzeugen und auf dem Ausgangsstapel ablegen. Die Zerlegung eines Stapels auf dem Eingangsstapel ist mit den Destruktoren \verb|top| und \verb|pop| möglich.

Wenn ein Stapel eine Folge von Daten enthält, dann sprechen wir auch immer wieder von einer Sequenz (\emph{sequence}). Repräsentiert der Inhalt eines Stapels ein Programm, dann sprechen wir von einer "`Quotierung"' (\emph{quotation}).

\begin{description}
\item[\texttt{emptystack ( -- [ ] )}] legt auf dem Ergebnisstapel einen leeren Stapel ab.
\end{description}

\begin{verbatim}
> clear emptystack
[ ]
\end{verbatim}

\begin{description}
\item[\texttt{push ( stk itm -- [ itm \& stk ] )}] erzeugt einen neuen Stapel, der das Ergebnis des Vorgangs ist, das Element \verb|itm| auf dem Stapel \verb|stk| abzulegen.
\end{description}

\begin{verbatim}
> clear [ 1 2 3 ] 4 push
[ 4 1 2 3 ]
\end{verbatim}

\begin{description}
\item[\texttt{top ( [ itm \& stk ] -- itm )}] legt das oberste Element \verb|itm| vom Stapel \verb|stk| auf dem Ergebnisstapel ab. Bei einem leeren Stapel oder \verb|nil| liefert \verb|top| als Ergebnis \verb|nil|. 
\end{description}

\begin{verbatim}
> clear [ 4 1 2 3 ] top
4
> [ ] top
4 nil
> nil top
4 nil nil
\end{verbatim}

\begin{description}
\item[\texttt{pop ( [ itm \& stk ] -- stk )}] legt den um das oberste Element reduzierten Stapel auf dem Ergebnisstapel ab.
\end{description}

\begin{verbatim}
> clear [ 1 2 3 ] pop
[ 2 3 ]
> [ ] pop
[ 2 3 ] [ ]
> nil pop
[ 2 3 ] [ ] [ ]
\end{verbatim}

Der Wert für "`Nichts"' (\emph{nil}), der von \verb|top| erzeugt und auch von \verb|pop| akzeptiert wird, hat eine Sonderfunktion. Er weist das Resultat von \verb|[ ] top| als erfolglos aus; es macht keinen Sinn, von einem leeren Stapel den obersten Wert zu verlangen. Mit \emph{nil} als Wert dennoch bei \verb|top| und \verb|pop| weiter arbeiten zu können, ermöglicht die effiziente Zerlegung von Stapeln, ohne stets überprüfen zu müssen, ob der Stapel inzwischen leer ist. Abseits dieses Einsatzzwecks sollten Sie auf \emph{nil} als Datenwert verzichten.

\begin{description}
\item[\texttt{reverse ( stk -- stk' )}] kehrt die Reihenfolge der Element in einem Stapel um.
\end{description}

\begin{verbatim}
> clear [ 1 2 3 4 5 ] reverse
[ 5 4 3 2 1 ]
\end{verbatim}

\begin{description}
\item[\texttt{concat ( stk1 stk2 -- stk3 )}] verbindet die Elemente der beiden Stapel \verb|stk1| und \verb|stk2| zu einem neuen Stapel \verb|stk3|. Die Reihenfolge der Elemente wird gemäß der Lesart von links nach rechts beibehalten. Ein leerer Stapel konkateniert lediglich seinen "`leeren"' Inhalt.
\end{description}

\begin{verbatim}
> clear [ 1 2 3 ] [ 4 5 ] concat
[ 1 2 3 4 5 ]
> [ ] concat
[ 1 2 3 4 5 ]
\end{verbatim}

Hinweis: Die Wörter \verb|reverse| und \verb|concat| sind ebenfalls Konstruktoren und bietet die Consize-VM aus Gründen der Performanz an. Sie können als optional betrachtet werden. Man könnte diese Wörter auch in der Prelude definieren.

% Gedanke: '[ ] [ 1 2 3 ] concat' könnte man als identitätserhaltend
% für den zweiten Stapel definieren.

\section{Mappings: \texttt{mapping}, \texttt{unmap}, \texttt{assoc}, \texttt{dissoc}, \texttt{get}, \texttt{keys}, \texttt{merge}}

Mappings dienen dazu, Schlüssel- mit Zielwerten zu assoziieren, weshalb diese Datenstruktur auch \href{http://de.wikipedia.org/wiki/Assoziatives_Datenfeld}{assoziatives Datenfeld} genannt wird. Wenn die Schlüsselwerte ausschließlich Wörter sind, dann nennen wir ein Mapping in Consize auch "`Wörterbuch"' (\emph{dictionary}). Mappings sind ein vielseitig verwendbarer Datentyp.

\begin{description}
\item[\texttt{mapping ( stk -- map )}] wandelt einen Stapel in ein Mapping um. Die Elemente auf dem Stapel werden paarweise als Schlüssel- und Zielwert interpretiert. Der Stapel muss eine gerade Anzahl an Elementen haben. Ein leerer Stapel liefert ein leeres Mapping.
\end{description}

\begin{verbatim}
> clear [ mon 1 tue 2 wed 3 thu 4 fri 5 ] mapping
{ thu 4 tue 2 mon 1 wed 3 fri 5 }
> clear [ ] mapping
{ }
\end{verbatim}

\begin{description}
\item[\texttt{unmap ( map -- stk )}] wandelt ein Mapping in einen Stapel, wobei die Assoziationen eine Folge von Schlüssel- und Zielwerten bilden. Die Reihenfolge der Schlüssel- und Zielwertpaare ist unbestimmt. Ein leeres Mapping führt zu einem leeren Stapel.
\end{description}

\begin{verbatim}
> clear { mon 1 tue 2 wed 3 thu 4 fri 5 } unmap
[ thu 4 tue 2 mon 1 wed 3 fri 5 ]
> clear { } unmap
[ ]
\end{verbatim}

\begin{description}
\item[\texttt{assoc ( val key map -- map' )}] fügt dem Mapping \verb|map| die Assoziation aus Schlüsselwert \verb|key| und Zielwert \verb|val| hinzu und liefert das neue Mapping \verb|map'| zurück. Existiert ein Schlüsselwert in \verb|map| bereits, wird der Zielwert "`über\-schrie\-ben"'.
\end{description}

\begin{verbatim}
> clear 3 :radius { :type circle } assoc
{ :radius 3 :type circle }
\end{verbatim}

\begin{description}
\item[\texttt{dissoc ( key map -- map' )}] legt ein Mapping \verb|map'| auf dem Ergebnisstapel ab, das alle Assoziationen des Mappings \verb|map| übernimmt bis auf die Assoziation, die über den Schlüsselwert \verb|key| identifiziert ist. Existiert \verb|key| in \verb|map| nicht, bleibt das Mapping unverändert.
\end{description}

\begin{verbatim}
> clear c { a b c d } dissoc
{ a b }
> clear c { a b } dissoc
{ a b }
\end{verbatim}

\begin{description}
\item[\texttt{get ( key map default -- val/default )}] liefert den mit dem Schlüsselwert \verb|key| im Mapping \verb|map| assoziierten Zielwert \verb|val| zurück. Existiert die Assoziation nicht, liefert \verb|get| stattdessen den \verb|default|-Wert zurück.
\end{description}

\begin{verbatim}
> clear thu { mon 1 tue 2 wed 3 thu 4 fri 5 } _|_ get
4
> clear sat { mon 1 tue 2 wed 3 thu 4 fri 5 } _|_ get
_|_
\end{verbatim}

\begin{description}
\item[\texttt{keys ( map -- seq )}] gibt alle Schlüsselwerte eines Mappings \verb|map| als Sequenz \verb|seq| (Stapel) zurück. Die Reihenfolge der Schlüsselwerte in \verb|seq| kann beliebig sein.
\end{description}

\begin{verbatim}
> clear { mon 1 tue 2 wed 3 thu 4 fri 5 } keys
[ thu tue mon wed fri ]
\end{verbatim}

\begin{description}
\item[\texttt{merge ( map1 map2 -- map3 )}] fasst die zwei Mappings \verb|map1| und \verb|map2| zu einem neuen Mapping \verb|map3| zusammen. Bei gleichen Schlüsselwerten in \verb|map1| und \verb|map2| werden die Assoziationen aus \verb|map2| in \verb|map3| übernommen.
\end{description}

\begin{verbatim}
> clear { a b c d } { c x y z } merge
{ a b c x y z }
\end{verbatim}

Hinweis: Nicht alle Wörter zu Mappings sind unabdingbar notwendig. Die Wörter \verb|unmap|, \verb|dissoc| und \verb|merge| bietet die Consize-VM aus Gründen der Performanz an. Sie können als optional betrachtet werden, da sie mit den übrigen Wörtern der Consize-VM nachgebildet werden können.

\section{Wörter: \texttt{unword}, \texttt{word}, \texttt{char}}

Ein Wort ist in Consize ein eigener Datentyp, der eine Folge von beliebigen Einzelzeichen (\emph{characters}) repräsentiert. Normalerweise verstehen wir in Consize unter einem Wort eine etwas striktere Auslegung: Ein Wort besteht aus mindestens einem oder mehr \emph{sichtbaren} Einzelzeichen. Diese strikte Interpretation liegt der Arbeitsweise von \verb|tokenize| zugrunde (Kap.~\ref{Sec:Parsing}). Tatsächlich kann ein Wort auch Leerzeichen und andere Steuerzeichen enthalten oder sogar leer sein. Das ist nützlich z.B. für die Erzeugung von Ausgaben auf der Konsole mittels \verb|print| (Kap.~\ref{sec:VM.Konsole}).

\begin{description}
\item[\texttt{unword ( wrd -- seq )}] zerlegt ein Wort in seine Einzelzeichen in Form einer Folge von Wörtern. Jedes Wort in der Folge entspricht einem Einzelzeichen.
\end{description}

\begin{verbatim}
> clear \ push unword
[ p u s h ]
\end{verbatim}

\begin{description}
\item[\texttt{word ( seq -- wrd )}] erwartet eine Folge von ausschließlich Wörtern und fügt diese Wörter zu einem neuen Gesamtwort zusammen. Die Folge muss mindestens ein Wort enthalten.
\end{description}

\begin{verbatim}
> clear [ it's me ! ] word
it'sme!
\end{verbatim}

\begin{description}
\item[\texttt{char ( wrd -- wrd' )}] legt auf dem Ergebnisstapel ein Wort \verb|wrd'| ab, das lediglich aus einem Einzelzeichen (\emph{character}) besteht. Das Einzelzeichen wird durch das Wort \verb|wrd| kodiert. Die Kodierung erfolgt als \href{http://de.wikipedia.org/wiki/Unicode}{Unicode} mit dem Präfix "`\verb|\u|"' und vier folgenden Stellen im \href{http://de.wikipedia.org/wiki/Hexadezimalsystem}{Hexadezimalsystem} (z.B. \verb|\u0040| für das Wort \verb|@|) oder im \href{http://de.wikipedia.org/wiki/Oktalsystem}{Oktalsystem} mit dem Präfix "`\verb|\o|"' (z.B.\ \verb|\o100| ebenfalls für \verb|@|). Zusätzlich stehen als Kodierung für \verb|wrd| die Wörter
\begin{itemize}
\item \verb|\space| (Leerzeichen, \emph{space}),
\item \verb|\newline| (Zeilenvorschub, \emph{line feed}),
\item \verb|\formfeed| (Seitenvorschub \emph{form feed}),
\item \verb|\return| (Wagenrücklauf, \emph{carriage return}),
\item \verb|\backspace| (Rückschritt, \emph{backspace}) und
\item \verb|\tab| (horizontaler Tabulator, \emph{tab})
\end{itemize}
zur Verfügung, denen die entsprechenden Zeichen bzw.\ \href{http://de.wikipedia.org/wiki/Steuerzeichen}{Steuerzeichen} als Wörter für \verb|wrd'| entsprechen. Beachten Sie, dass \verb|\space| etc.\ mit \verb|char| "`unsichtbare"' Wörter erzeugen, die z.B.\ bei der Ausgabe über die Konsole dennoch Auswirkungen als \href{http://de.wikipedia.org/wiki/Leerraum}{Leerraum} haben. Der vorrangige Nutzen von \verb|char| besteht in der Erzeugung von Sonderzeichen über die Unicode-Kodierung.
\end{description}

\begin{verbatim}
> clear \u0040 char
@
\end{verbatim}

\section{Konsole: \texttt{print}, \texttt{flush}, \texttt{read-}\-\texttt{line}}
\label{sec:VM.Konsole}

Zur Ein- und Ausgabe über die Konsole stellt Consize drei Wörter bereit. In der Regel erscheinen Ausgaben nicht direkt auf dem Bildschirm, sondern wandern zunächst in einen Zwischenspeicher, einen \href{http://de.wikipedia.org/wiki/Puffer_(Informatik)}{Puffer}.

\begin{description}
\item[\texttt{print ( wrd -- )}] gibt das Wort auf der Konsole aus. Da die Ausgabe über einen \href{http://de.wikipedia.org/wiki/Puffer\_(Informatik)}{Puffer} erfolgt, kann die Ausgabe möglicherweise nicht direkt, sondern zu einem späteren Zeitpunkt erfolgen. Die sofortige Ausgabe erzwingt \verb|flush|. 
\end{description}

\begin{verbatim}
> clear \ Hello print \newline char print
Hello

\end{verbatim}

\begin{description}
\item[\texttt{flush ( -- )}] leert den Ausgabepuffer und bringt alles, was noch im Ausgabepuffer ist, zur Ausgabe in der Konsole. Das Wort "`\emph{flush}"' heißt soviel wie "`ausspülen"'.
\end{description}

\begin{verbatim}
> clear \ Hi print \newline char print flush
Hi

\end{verbatim}

\begin{description}
\item[\texttt{read-line ( -- wrd )}] liest eine Zeile über die Konsole ein. Sobald die Eingabe mit der \href{http://de.wikipedia.org/wiki/Eingabetaste}{Eingabetaste} abgeschlossen ist, legt \verb|read-line| die Eingabezeile als Wort auf dem Ergebnisstapel ab.
\end{description}

Geben Sie in dem nachstehenden Beispiel nach \verb|read-line| über die Tastatur "`Hello you"' ein und schließen Sie die Eingabe mit der Eingabetaste ab.

\begin{verbatim}
> clear read-line
Hello you
Hello you
\end{verbatim}

Die Ausgabe lässt den Eindruck aufkommen, als handele es sich um zwei Wörter auf dem Ergebnisstapel. Tatsächlich ist \verb|Hello you| ein einziges Wort, das ein Leerzeichen beinhaltet! Das wird offensichtlich, wenn Sie ein \verb|dup| eingeben.

\begin{verbatim}
> dup
Hello you Hello you
\end{verbatim}

\section{Dateien und mehr: \texttt{slurp}, \texttt{spit}, \texttt{spit-on}}

Consize unterstützt nur sehr rudimentär die Arbeit mit dem \href{http://de.wikipedia.org/wiki/Dateisystem}{Dateisystem}: das Lesen von Dateien mit \verb|slurp| und das Schreiben von Daten in Dateien mit \verb|spit| und \verb|spit-on|. Consize ist absichtlich nicht mit weiteren Fähigkeiten zum Löschen von Dateien und zum Navigieren durch das Dateisystem ausgestattet.

\begin{description}
\item[\texttt{slurp ( source -- wrd )}] interpretiert das Wort \verb|source| als Datenquelle, liest die Daten von dort ein und legt die Daten als Wort \verb|wrd| auf dem Ergebnisstapel ab. Nur Datenquellen mit Textdaten können sinnvoll verarbeitet werden. Bei einfachen Wortnamen für \verb|source| liest Consize die Daten von einer namensgleichen Datei ein, die sich im Aufrufverzeichnis von Consize befindet. Die Konventionen für Dateipfade folgen \href{http://docs.oracle.com/javase/7/docs/api/java/io/File.html}{java.io}. Es können auch Daten aus dem World Wide Web gelesen werden, siehe Beispiel.
\end{description}

Das folgende Beispiel zeigt, dass Sie auch Daten über das \href{http://de.wikipedia.org/wiki/Http}{Hypertext Transfer Protokoll} (HTTP) lesen können, sofern Sie online sind. Das gelieferte Ergebnis ist der Inhalt eines einzigen Wortes. Auch hier gilt wie bei \verb|read-line|: Das Wort \verb|wrd| kann Leerzeichen, Sonder- und Steuerzeichen enthalten. Die beispielhafte Ausgabe ist natürlich abhängig vom aktuellen Inhalt der Webseite. Der besseren Lesbarkeit wegen habe ich Zeilenumbrüche hinzugefügt.

\begin{verbatim}
> clear http://m.twitter.com slurp
<html><body>You are being
<a href="https://mobile.twitter.com/signup">redirected</a>.
</body></html>
\end{verbatim}

\begin{description}
\item[\texttt{spit ( data-wrd file-wrd -- )}] schreibt das Wort \verb|data-wrd| in eine Datei unter dem Namen \verb|file-wrd| in das Dateisystem. Für \verb|file-wrd| gelten die Konventionen wie unter \verb|slurp| erwähnt. Existiert die Datei nicht, wird sie neu angelegt. Existiert die Datei bereits, wird ihr bisheriger Inhalt überschrieben.
\end{description}

Nach Eingabe des Beispiels sollten Sie im Startverzeichnis von Consize eine Datei namens \verb|dummy.txt| finden. Öffnen Sie die Datei mit einem Editor, um sich den Inhalt anzuschauen.

\begin{verbatim}
> clear \ Hello \ dummy.txt spit

\end{verbatim}

\begin{description}
\item[\texttt{spit-on ( data-wrd file-wrd -- )}] hängt das Wort \verb|data-wrd| an den Inhalt der Datei unter dem Namen \verb|file-wrd| an. Für \verb|file-wrd| gelten die Konventionen wie unter \verb|slurp| erwähnt.
\end{description}

Wenn Sie das Beispiel zu \verb|spit| ausgeführt haben, hängt Ihnen das folgende Beispiel ein \verb|You| an. In der Datei steht anschließend \verb|HelloYou|.

\begin{verbatim}
> clear \ You \ dummy.txt spit-on

\end{verbatim}

\section{Parsing: \texttt{uncomment}, \texttt{tokenize}, \texttt{undocument}}
\label{Sec:Parsing}

Die Wörter \verb|uncomment|, \verb|undocument| und \verb|tokenize| bearbeiten den durch ein Wort repräsentierten Inhalt seiner Einzelzeichen. Die Wörter sind insbesondere dafür gedacht, über \verb|read-line| oder \verb|slurp| eingelesene Consize-Programme einer Vorverarbeitung zu unterziehen.

\begin{description}
\item[\texttt{uncomment ( wrd -- wrd' )}] entfernt aus einem Wort alle Kommentare. Ein Kommentar beginnt mit dem \verb|%|-Zeichen
und geht bis zum Ende einer Zeile. Das Zeilenende wird durch einen \href{http://de.wikipedia.org/wiki/Zeilenumbruch}{Zeilenumbruch} markiert. Je nach Betriebssystem markieren die \href{http://de.wikipedia.org/wiki/Steuerzeichen}{Steuerzeichen} "`\href{http://de.wikipedia.org/wiki/Wagenr\%C3\%BCcklauf}{Wagenrücklauf}"' (\emph{carriage return}, CR) und\slash oder "`\href{http://de.wikipedia.org/wiki/Zeilenvorschub}{Zeilenvorschub}"' (\emph{line feed}, LF) den Zeilenumbruch.
\end{description}

Da \verb|read-line| im folgenden Beispiel keinen Marker für das Zeilenende setzt, müssen wir ein \verb|\newline char| zu dem eingelesenen Wort hinzufügen, damit \verb|uncomment| den Kommentar entfernen kann.

\begin{verbatim}
> read-line
This line % has a comment
This line % has a comment
> [ ] \newline char push swap push word uncomment
This line
\end{verbatim}

\begin{description}
\item[\texttt{tokenize ( wrd -- seq )}] zerlegt das Wort an vorhandenen Leerraum-Stellen in eine Folge von Wörtern.
Als \href{http://de.wikipedia.org/wiki/Leerraum}{Leerraum} (\emph{whitespace character} gilt eine nicht leere Folge bzw.\ Kombination der folgenden Zeichen: Leerzeichen, horizontaler Tabulator, vertikaler Tabulator, Zeilenvorschub, Seitenvorschub und
Wagenrücklauf. Diese Definition eines Leerraums folgt dem \href{http://de.wikipedia.org/wiki/POSIX}{POSIX}-Standard für
\href{http://de.wikipedia.org/wiki/Regul\%C3\%A4rer\_Ausdruck}{reguläre Ausdrücke}.
\end{description}

\begin{verbatim}
> read-line tokenize
This line % has a comment
[ This line % has a comment ]
\end{verbatim}

\begin{description}
\item[\texttt{undocument ( wrd -- wrd' )}] extrahiert aus einem Wort lediglich die "`Zeilen"', die mit einem "`\verb|>> |"' bzw.\ "`\verb|%> |"'
(jeweils mit einem Leerzeichen) beginnen, verwirft dabei jedoch diese Anfänge. Die extrahierten Anteile werden per Wagenrücklauf und Zeilenvorschub miteinander verknüpft und als neues Wort \verb|wrd'| zurück gegeben.
\end{description}

Mit \verb|uncomment| unterstützt Consize eine schwache Form des \href{http://de.wikipedia.org/wiki/Literate\_programming}{\emph{Literate Programming}}, wie sie auch die funktionale Programmiersprache \href{http://de.wikipedia.org/wiki/Haskell\_(Programmiersprache)}{Haskell} anbietet. Das Literate Programming zielt darauf ab, nicht den Code zu dokumentieren, sondern die Dokumentation mit Code anzureichern. Die Idee des Literate Programming stammt von \href{http://de.wikipedia.org/wiki/Donald_Ervin_Knuth}{Donald E.\ Knuth}, dem Schöpfer von \href{http://de.wikipedia.org/wiki/TeX}{\TeX}.

So haben Sie zwei Möglichkeiten: Sie schreiben entweder Programmcode und reichern ihn mit Kommentaren an, die durch ein Prozentzeichen ausgewiesen sind; dann entfernt \verb|uncomment| die Kommentare aus dem Consize-Code. Oder Sie schreiben eine Dokumentation und reichern diese mit Programmcode an, der Code ist durch "`\verb|>> |"' bzw.\ "`\verb|%>> |"'
auszuweisen; dann entfernt \verb|undocument| die Dokumentation und lässt den Consize-Code übrig, den man in einem weiteren Schritt von Kommentaren per \verb|uncomment| befreien kann.

Hinweise: Alle Parsing-Wörter sind nicht strikt erforderlich. Sie können allesamt durch Programme aus den übrigen Wörtern der Consize-VM nachgebildet werden und sind deshalb als optional zu betrachten. Aus Gründen der Performanz sind sie jedoch als fester Bestandteil der Consize-VM empfohlen. 

\section{Funktionen: \texttt{apply}, \texttt{func}, \texttt{compose}}

Die Bedeutung atomarer Wörter ist über die mit ihnen assoziierten Funktionen definiert. Diese Funktionen sind fest vorgegeben und heißen auch \emph{primitive Funktionen}. Mit \verb|apply| wird eine Funktion auf einen Stapel angewendet, und mit \verb|func| können eigene Funktionen definiert werden. Das Wort \verb|compose| erlaubt die Komposition zweier Funktionen zu einer neuen Funktion.

\begin{description}
\item[\texttt{apply ( stk fct -- stk' )}] wendet die Funktion \verb|fct| auf den Stapel \verb|stk| an. Das Ergebnis der \href{http://en.wikipedia.org/wiki/Apply}{Funktionsanwendung} ist \verb|stk'|.
\end{description}

Im Beispiel wird die mit \verb|rot| im Wörterbuch assoziierte primitive Funktion auf den Stapel \verb|[ 1 2 3 ]| angewendet.

\begin{verbatim}
> clear [ 1 2 3 ] \ rot get-dict nil get
[ 1 2 3 ] <fct>
> apply
[ 3 1 2 ]
\end{verbatim}

\begin{description}
\item[\texttt{func ( quot dict -- fct )}] erzeugt eine Funktion und initialisiert sie mit einer Quotierung \verb|quot| als Programm und einem im Kontext der Funktion gültigen Wörterbuch \verb|dict|. Die Semantik der Anwendung dieser Funktion auf einen Stapel (z.B. per \verb|apply|) ist wie folgt definiert: Der Stapel sei der initiale Datastack, die Quotierung \verb|quot| der initiale Callstack und \verb|dict| das initiale Wörterbuch. \verb|stepcc| wird solange wiederholt mit dem sich verändernden Triple aus Callstack, Datastack und Wörterbuch aufgerufen, bis der Callstack leer ist. Als Ergebnis der Anwendung der per \verb|func| erzeugten Funktion wird lediglich der Datastack als "`normaler"' Stapel (wie in \verb|apply|) zurück gegeben.
%
% Sinngemäß gilt:
% : func apply ( ds cs dict -- ds' )
%   -rot dup empty?
%     [ drop swap drop ]
%     [ stepcc rot func apply ]
%   if ;
\end{description}

\begin{verbatim}
> clear [ 1 2 3 ] [ rot ] get-dict func
[ 1 2 3 ] <fct>
> apply
[ 3 1 2 ]
> clear [ 1 2 3 ] [ rot swap ] get-dict func apply
[ 1 3 2 ]
\end{verbatim}

Wenn ein Fehler bei der Anwendung einer mit \verb|func| definierten Funktion auftritt, dann wird das Wort \verb|error| auf dem Callstack abgelegt. Die Bedeutung von \verb|error| ist frei definierbar und nicht vorgegeben.

% Die Komposition zweier Funktionen per \verb|compose| liefert eine neue Funktion. 

\begin{description}
\item[\texttt{compose ( fct1 fct2 -- fct3 )}] liefert die Funktion \verb|fct3| als Ergebnis der \href{http://de.wikipedia.org/wiki/Komposition_(Mathematik)}{Komposition} von \verb|fct1| und \verb|fct2| zurück.
\end{description}

Die Bedeutung der per \verb|compose| erzeugten Funktion ist indirekt definiert: Die Anwendung der Funktion \verb|fct3| auf einen Stapel \verb|stk| liefert das gleiche Resultat wie die Anwendung von \verb|fct1| auf \verb|stk| mit folgender Anwendung von \verb|fct2| auf dieses Ergebnis. Anders ausgedrückt: Die Programme \verb|compose apply| und \verb|[ apply ] bi@| sind ergebnisgleich. Der Apply-Kombinator \verb|bi@| ist in der Prelude definiert, siehe Kap.~\ref{Sec:applyCombinators}.

\begin{verbatim}
> clear [ 1 2 3 ] \ rot get-dict nil get \ swap get-dict nil get
[ 1 2 3 ] <fct> <fct>
> compose
[ 1 2 3 ] <fct>
> apply
[ 1 3 2 ]
\end{verbatim}

\section{Der Interpreter: \texttt{stepcc}}
\label{Sec:stepcc}
% \texttt{call}, \texttt{\char "5C}}

Die Definition des Interpreters kommt mit drei Konzepten aus: der Konkatenation, der Funktionsanwendung und dem Nachschlagen eines Wortes im Wörterbuch. Die zentrale Stellung der Konkatenation ist der Grund für die Charakterisierung von Consize als konkatenative Sprache. Eher nebensächlich ist, ob es bei der Konkatenation um Stapel, Arrays, Vektoren, Ströme, generell um Folgen irgendwelcher Art geht. Da Consize stapelbasiert ist, kann die Konkatenation in manchen Fällen durch ein \verb|push| eines Elements auf den Stapel ersetzt werden. Aber das ist eher ein Detail der Implementierung, weniger ein konzeptuelles.

\begin{description}\label{description.stepcc}
\item[\texttt{stepcc ( dict ds cs -- dict' ds' cs' )}] erwartet auf dem Eingangsstapel zwei Stapel \verb|cs| und \verb|ds|, die wir Callstack und Datastack nennen, und ein Wörterbuch \verb|dict|. Der Callstack \verb|cs| muss mindestens ein Element enthalten! Das Wort \verb|stepcc| definiert einen Rechenschritt in Consize als Ver\-än\-de\-rung\-en bezüglich des Callstacks, des Datastacks und des Wör\-ter\-buchs.
%
Zum leichteren Verständnis vereinbaren wir folgende \href{http://de.wikipedia.org/wiki/Substitution\_(Logik)}{Substitutionen} (Ersetzungen):\footnote{Bitte verwechseln Sie das Gleichheitszeichen auf keinen Fall mit einer Zuweisung.}
\begin{itemize}
\item \verb|cs| $=$ \verb|[ itm ] rcs concat|. Der nicht-leere Callstack kann verstanden werden als Konkatenation einer Sequenz mit einem Element \verb|itm| und den "`restlichen"' Elementen \verb|rcs|; \verb|itm| repräsentiert das oberste Element auf dem Callstack.
\item \verb|res| $=$ \verb|itm dict nil get|. Der mit dem obersten Element des Callstacks assoziierte Wert im Wörterbuch sei durch \verb|res| erfaßt; ist kein Eintrag zu \verb|itm| im Wörterbuch zu finden, so ist \verb|res| $=$ \verb|nil|.
\end{itemize}
Die Veränderungen auf dem Ergebnisstapel seien ebenfalls in Form von Substitutionen für \verb|cs'|, \verb|ds'| und \verb|dict'| notiert. Sofern in den folgenden Fallunterscheidungen nichts anderes angegeben ist, gilt grundsätzlich \verb|cs'| $=$ \verb|rcs|, \verb|ds'| $=$ \verb|ds|, \verb|dict'| $=$ \verb|dict|.
\begin{enumerate}
\item Ist \verb|itm| ein Wort,
  \marginpar{Wort auf Callstack nachschlagen:}
  dann schlage das Wort im Wörterbuch nach und betrachte das 
  Resultat \verb|res|.
  \begin{enumerate}
  \item Ist \verb|res| ein Stapel (Quotierung\slash Programm):
    \marginpar{-- Stapel: Programmaufruf} % call!!!
    \newline\verb|cs'| $=$ \verb|res rcs concat|
  \item Ist \verb|res| eine Funktion:
    \marginpar{-- Funktion: Anwendung auf Datastack}
    \newline\verb|ds'| $=$ \verb|ds res apply|
  \item weder\slash noch:
    \marginpar{-- sonst: Wort inspizieren}
    \newline\verb|ds'| $=$ \verb|[ itm ] ds concat|,
    \newline\verb|cs'| $=$ \verb|[ read-word ] rcs concat|
  \end{enumerate}
\item Ist \verb|itm| ein Mapping:
  \marginpar{Mapping auf Callstack:}
  \newline\verb|ds'| $=$ \verb|[ itm ] ds concat|,
  \marginpar{-- Mapping inspizieren}
  \newline\verb|cs'| $=$ \verb|[ read-mapping ] rcs concat|
\item Ist \verb|itm| eine Funktion, \label{stepcc:fct}
  \marginpar{Funktion auf Callstack:}
  so wird die Funktion angewendet auf den Eingangsstapel mit dem
  \marginpar{-- Anwendung auf alles}
  kleinen Unterschied, dass \verb|rcs| statt \verb|cs| verwendet wird.
  Der Ergebnisstapel ist das Resultat von: 
  \newline\verb|[ rcs ds dict ] r concat itm apply|
  \newline Mit \verb|r| seien die "`restlichen"' Elemente des 
  Eingangsstapels ohne die führenden drei Elemente des Stapeleffekts
  (\verb|cs|, \verb|ds| und \verb|dict|) erfasst.
\item Ist \verb|itm| entweder ein Stapel oder \verb|nil|:
  \marginpar{Stapel\slash\texttt{nil} auf Callstack:}
  \newline\verb|ds'| $=$ \verb|[ itm ] ds concat|
  \marginpar{-- auf Datastack ablegen}
\end{enumerate}
\end{description}
% : runcc ( dict ds cs -- dict' ds' [ ] )
%   dup empty? [ stepcc runcc ] until ;
% 
% : runcc ( dict ds cs -- dict' ds' [ ] )
%   dup { [ ] [ ] } [ stepcc runcc ] get call ;

In dieser formalen Darstellung stellt sich die Spezifikation des Verhaltens von \verb|stepcc| ein wenig komplizierter dar, als sie es wirklich ist. Freisprachlich formuliert arbeitet \verb|stepcc| wie folgt:

Befindet sich auf dem Callstack ein Wort und findet sich zu diesem Wort im Wör\-ter\-buch eine Quotierung, dann ersetzt der Inhalt der Quotierung das Wort auf dem Callstack. Die Ersetzung geschieht durch Konkatenation der Quotierung mit dem Rest des Callstacks.

\begin{verbatim}
> clear { \ -rot [ rot rot ] } [ z y x ] [ -rot swap ] stepcc
{ -rot [ rot rot ] } [ z y x ] [ rot rot swap ]
\end{verbatim}

Findet sich im Wörterbuch stattdessen eine Funktion, dann wird die Funktion auf den Datastack angewendet. Mit \verb|get-dict| und \verb|get| schlagen wir die zu \verb|rot| hinterlegte Funktion im Wörterbuch nach.

\begin{verbatim}
> clear \ rot get-dict nil get \ rot { } assoc
{ rot <fct> }
> [ z y x ] [ rot rot swap ] stepcc
{ rot <fct> } [ x z y ] [ rot swap ]
\end{verbatim}

Findet sich zu dem Wort im Wörterbuch kein Eintrag oder ist es im Wörterbuch weder mit einer Quotierung noch mit einer Funktion assoziiert, dann gilt das Wort als unbekannt. Das Wort wird auf dem Datastack abgelegt und auf dem Callstack durch \verb|read-word| ersetzt.

\begin{verbatim}
> clear { } [ z y x ] [ rot swap ] stepcc
{ } [ rot z y x ] [ read-word swap ]
\end{verbatim}

Auf diese Weise kann mittels \verb|read-word| ein Verhalten für unbekannte Wörter vom Anwender selbst definiert werden.
Anders ausgedrückt: \verb|read-word| ist ein Meta-Wort zur Definition des Umgangs mit unbekannten Wörtern.
% Ein Meta-Wort verweist auf die Existenz einer \href{http://de.wikipedia.org/wiki/Metaebene}{Metaebene}, die es erlaubt, das Verhalten von Elementen auf der "`Sachebene"' zu beschreiben.

Ähnlich ist der Umgang mit Mappings. Ist das oberste Element auf dem Callstack kein Wort, sondern ein Mapping, dann wird das Mapping auf dem Datastack abgelegt und auf dem Callstack durch \verb|read-mapping| ersetzt. Das Wort \verb|read-mapping| ist ein Meta-Wort, mit dem man das Verhalten im Umgang mit Mappings frei definieren kann.

\begin{verbatim}
> clear { } [ z y x ] [ { a b } swap ] stepcc
{ } [ { a b } z y x ] [ read-mapping swap ]
\end{verbatim}

Ist das oberste Element auf dem Callstack weder ein Wort noch ein Mapping, sondern eine Funktion, dann wende die Funktion auf den gesamten Eingangsstapel an, mit dem \verb|stepcc| aufgerufen wurde. Das Beispiel ist zwar wenig sinnhaft, zeigt aber dennoch, wie \verb|rot| nicht auf den durch \verb|[ 1 2 3 ]| repräsentierten Datastack der Continuation arbeitet, sondern auf dem Eingangsstapel.

\begin{verbatim}
> clear { } [ 1 2 3 ] [ ] \ rot get-dict nil get push
{ } [ 1 2 3 ] [ <fct> ]
> stepcc
[ 1 2 3 ] [ ] { }
\end{verbatim}

Ist das oberste Elemente auf dem Callstack weder ein Wort noch ein Mapping noch eine Funktion, dann muss es sich um einen Stapel oder \verb|nil| handeln; mehr als diese fünf Datentypen gibt es nicht. Ein Stapel bzw. \verb|nil| wandert vom Callstack auf den Datastack.\footnote{Ich verwende die runden Klammern, damit \texttt{nil} als Datenwert \textit{nil} und nicht als Wort \texttt{nil} in dem Stapel liegt.}

\begin{verbatim}
> clear { } [ z y x ] ( [ 1 2 3 ] nil ) stepcc
{ } [ [ 1 2 3 ] z y x ] [ nil ]
> stepcc
{ } [ nil [ 1 2 3 ] z y x ] [ ]
\end{verbatim}

%\attention Die Bedeutung von \verb|stepcc| ist, dass es gemeinsam mit \verb|func| den "`Antriebsmotor"' von Consize definiert. Eine mit \verb|func| erzeugte und mit \verb|apply| auf einen Stapel angewendete Funktion ist in ihrer Ausführung zu verstehen als fortwährende Anwendung von \verb|stepcc| auf die via \verb|func| und \verb|apply| gegebene vollständige Continuation -- und zwar solange, bis der Callstack der vollständigen Continuation abgearbeitet, sprich leer ist. Das Ergebnis der Abarbeitung ist der Datastack.

Die Wörter \verb|read-word| und \verb|read-mapping| definieren ein einfaches Metaprotokoll. Mit ihnen kann das Verhalten bei einem unbekannten Wort oder bei einem Mapping auf dem Callstack frei definiert werden. Ohne eine Definition für \verb|read-word| wird bei Interpretation eines unbekannten Wortes eine Endlosschleife losgetreten: Wenn \verb|read-word| unbekannt ist, wird per \verb|read-word| nach der Bedeutung von \verb|read-word| gefahndet.

\section{Metaprogrammierung mit \texttt{call/cc}, \texttt{continue}, \texttt{get-dict}, \texttt{set-dict}, \texttt{{\char "5C}}}
\label{sec:core.meta}

In dem durch \verb|stepcc| definierten Interpreter sind auch ohne Fall~\ref{stepcc:fct} (Funktion auf Callstack) die entscheidenden Mechanismen angelegt, um ein turingmächtiges Rechensystem zu realisieren. Fall~\ref{stepcc:fct} erweitert den Interpreter um die Möglichkeit der \href{http://de.wikipedia.org/wiki/Metaprogrammierung}{Metaprogrammierung}, einer Funktion wird der gesamte Zustand des Interpreters zur freien Manipulation übergeben. Damit ist all das möglich, was in anderen Programmiersprachen als \href{http://de.wikipedia.org/wiki/Reflexion_(Programmierung)}{Reflexion} (\emph{reflection}) oder Introspektion (\emph{introspection}) bezeichnet wird.

Das Wort \verb|call/cc| (\emph{call with current continuation}) dient als Einstieg zur Manipulation von Call- und Datastack. Call- und Datastack werden in Kombination auch als "`\href{http://de.wikipedia.org/wiki/Continuation}{Continuation}"' bezeichnet. Mit \verb|continue| wird der Meta-Modus beendet und die meist über \verb|call/cc| unterbrochene und manipulierte Continuation fortgesetzt (darum \emph{continue}). Mit \verb|set-dict| kann der aktuelle Programmkontext, das Wörterbuch gesetzt und mit \verb|get-dict| gelesen werden.

Die Stapeleffekte zu den Wörtern sind, wie gehabt, die Effekte der Funktionen auf Eingangs- und Ausgangsstapel. Dennoch gibt es einen wichtigen Unterschied: Die Wörter sind im Wörterbuch nicht direkt mit den Funktionen assoziiert, die Funktionen sind in einem Stapel eingepackt.
Das hat eine entscheidende Konsequenz bei der Interpretation des Wortes durch \verb|stepcc|: Der Stapel wird im ersten Schritt mit dem Callstack konkateniert; damit befindet sich die Funktion als oberstes Element auf dem Callstack. Im zweiten Schritt greift dann der \ref{stepcc:fct}.~Fall in \verb|stepcc|, und die Funktion wird angewendet auf den aktuellen, gesamten Zustand aus Callstack, Datastack und Wörterbuch des Interpreters.

\begin{description}
\item[\texttt{call/cc ( [ quot \& ds ] cs -- [ cs ds ] quot )}] erwartet zwei Stapel, die Continuation aus Callstack \verb|cs| und Datastack \verb|ds|, wobei sich auf dem Datastack als oberstes Element eine Quotierung \verb|quot| befindet.
Die Quotierung \verb|quot| übernimmt als "`neuer"' Callstack das Ruder der Programmausführung, die Continuation aus \verb|cs| und \verb|ds| bildet den Inhalt des "`neuen"' Datastacks. Das durch \verb|quot| repräsentierte Programm kann nun die auf dem Datastack abgelegte Continuation beliebig manipulieren.
\end{description}

\begin{description}
\item[\texttt{continue ( [ cs ds \& r ] quot -- ds cs )}] ist das Gegenstück zu \verb|call/cc|. Das Wort erwartet zwei Stapel, die Continuation aus der Quotierung \verb|quot| (die durch \verb|call/cc| in den Rang des ausführenden, aktuellen Callstacks erhoben wurde) und dem Datastack auf dem sich die übernehmende Continuation befindet \verb|[ cs ds & r ]|. Weitere Elemente auf dem Datastack werden ignoriert, d.h. \verb|r| spielt keine Rolle. Mit \verb|cs| und \verb|ds| wird die "`neue"' Continuation gesetzt.
\end{description}

Als Beispiel für \verb|call/cc| und \verb|continue| diene die Implementierung des \emph{backslash}-Wortes "`\verb|\|"'. Der Backslash ist Teil der Consize-VM.
% Der Backslash sorgt dafür, dass das ihm folgende Wort unmittelbar auf dem Datastack abgelegt wird. Auf diese Weise kann z.B. die Interpretation eines atomaren Worter unterbunden werden. Das Wort landet unbesehen als Datum auf dem Datastack -- im nachfolgenden Fall ist es \verb|swap|.

\begin{description}
\item[\texttt{{\char "5C}\ ( ds [ \ wrd \& cs ] -- [ wrd \& ds ] cs )}] legt das dem Wort \verb|\| folgende Element auf dem Callstack direkt auf dem Datastack ab. Das Wort \verb|\| wird auch als "`Quote"' oder "`Escape"' bezeichnet. Es verhindert die Interpretation von Daten auf dem Callstack. Das Wort ist definiert über das folgende Programm:
\begin{verbatim}
: \ ( ds [ \ wrd & cs ] -- [ wrd & ds ] cs )   
  [ dup top rot swap push swap pop continue ] call/cc ;
\end{verbatim}
\end{description}

Im Beispiel wird das dem Quote folgende \verb|swap| auf dem Datastack abgelegt, während das zweite, unquotierte \verb|swap| seinen "`normalen"' Dienst verrichtet.

\begin{verbatim}
> clear 1 2 \ swap swap
1 swap 2
\end{verbatim}

Die Interpretation des Wortes \verb|\| triggert die Ablage der aktuellen Continuation auf dem Datastack. Die Quotierung zu \verb|call/cc| sorgt dann für den Transfer des Wortes vom Call- auf den Datastack. Sie können das leicht nachvollziehen, wenn Sie \verb|\| durch ein \verb|break| im Beispiel ersetzen.

\begin{verbatim}
> clear 1 2 break swap swap
[ 2 1 ] [ swap swap printer repl ]
\end{verbatim}

Nun sehen Sie die Inhalte der im Moment von \verb|break| gültigen Continuation und können händisch die Manipulation durchführen. Per \verb|continue| wird anschließend die Programmausführung an die veränderte Continuation übergeben.

\begin{verbatim}
> dup top rot swap push swap pop
[ swap 2 1 ] [ swap printer repl ]
> continue
1 swap 2
\end{verbatim}

\begin{description}
\item[\texttt{get-dict ( dict ds cs -- dict [ dict \& ds ] cs )}] erwartet die Continuation aus \verb|cs| und \verb|ds| samt Wörterbuch \verb|dict| und legt ein Duplikat des Wörterbuchs als oberstes Element auf dem Datastack ab.
\end{description}

Wenn Sie \verb|get-dict| an der Konsole eingeben, dauert die Aufbereitung der Ausgabe eine Weile. Haben Sie ein wenig Geduld. Zwar ist die Ausgabe umfangreicher Wörterbücher oder Mappings wenig sinnvoll, aber Sie bekommen einen Einblick, was so alles im Wörterbuch steht.

\begin{verbatim}
> clear get-dict
% output deliberately omitted
\end{verbatim}

\begin{description}
\item[\texttt{set-dict ( dict [ dict' \& ds ] cs -- dict' ds cs )}] 
erwartet die Continuation aus \verb|cs| und \verb|ds| samt Wörterbuch \verb|dict|, wobei sich auf dem Datastack als oberstes Element ein Wörterbuch \verb|dict'| befindet. Das Wörterbuch \verb|dict'| ersetzt das Wörterbuch \verb|dict|.
\end{description}

Im Beispiel fügen wir dem Wörterbuch das Wort \verb|square| mit einer Quotierung hinzu.

\begin{verbatim}
> clear [ dup * ] \ square get-dict assoc set-dict

> 4 square
16
\end{verbatim}

\section{Arithmetik: \texttt{+}, \texttt{-}, \texttt{*}, \texttt{div}, \texttt{mod}, \texttt{<}, \texttt{>}, \texttt{integer?}}

Consize bietet ein paar Wörter an, die Wörter als Zahlen interpretieren und damit das Rechnen mit Zahlen (\href{http://de.wikipedia.org/wiki/Arithmetik}{Arithmetik}) sowie einfache Zahlenvergleiche (größer, kleiner) ermöglichen. Nachfolgend sind die Angaben \verb|x|, \verb|y| und \verb|z| in den Stapeleffekten Wörter, die \href{http://de.wikipedia.org/wiki/Ganze\_Zahlen}{ganze Zahlen} repräsentieren. Allerdings sind Ganzzahlen nicht als eigenständiger Datentyp in Consize vertreten, Zahlen sind Wörter.

\begin{description}
\item[\texttt{+ ( x y -- z )}] liefert mit \verb|z| die Summe \verb|x|$+$\verb|y| zurück; \verb|+| realisiert die \href{http://de.wikipedia.org/wiki/Addition}{Addition}.
\end{description}

\begin{verbatim}
> 2 3 +
5
\end{verbatim}

\begin{description}
\item[\texttt{- ( x y -- z )}] liefert mit \verb|z| die Differenz \verb|x|$-$\verb|y| zurück; \verb|-| realisiert die \href{http://de.wikipedia.org/wiki/Subtraktion}{Subtraktion}.
\end{description}

\begin{verbatim}
> 2 3 -
-1
\end{verbatim}

\begin{description}
\item[\texttt{* ( x y -- z )}] liefert mit \verb|z| das Produkt \verb|x|$\cdot$\verb|y| zurück; \verb|*| realisiert die \href{http://de.wikipedia.org/wiki/Multiplikation}{Multiplikation}.
\end{description}

\begin{verbatim}
> 2 3 *
6
\end{verbatim}

\begin{description}
\item[\texttt{div ( x y -- z )}] liefert mit \verb|z| den ganzzahligen Wert des Quotienten \verb|x|$:$\verb|y| zurück; \verb|div| realisiert die ganzzahlige \href{http://de.wikipedia.org/wiki/Division\_(Mathematik)}{Division}. Der Divisor \verb|y| muss von \verb|0| verschieden sein.
\end{description}

\begin{verbatim}
> 7 3 div
2
\end{verbatim}

\begin{description}
\item[\texttt{mod ( x y -- z )}] liefert mit \verb|z| den Rest der Division \verb|x|$:$\verb|y| zurück; \verb|mod| realisiert den Divisionsrest, "`\href{http://de.wikipedia.org/wiki/Modulo#Modulo}{Modulo}"' genannt.
%(Siehe auch "`\href{http://de.wikipedia.org/wiki/Modulo#Implementierung\_in\_Computersystemen}{Implementierung in Computersystemen}"'.)
Die Zahl \verb|y| muss von \verb|0| verschieden sein.
\end{description}

\begin{verbatim}
> 7 3 mod
1
\end{verbatim}

Die Vergleichsoperatoren \verb|<|, \verb|>| etc.\ nutzen die \href{http://de.wikipedia.org/wiki/Ordnungsrelation}{Ordnungsrelation} unter den Zahlen, die man sich z.B.\ anhand eines \href{http://de.wikipedia.org/wiki/Zahlengerade}{Zahlenstrahls} veranschaulichen kann.

\begin{description}
\item[\texttt{< ( x y -- t/f )}] liefert als Ergebnis des Vergleichs \verb|x|$<$\verb|y| entweder \verb|t| (für wahr, \emph{true}) oder \verb|f| (für falsch, \emph{false}) zurück.
\end{description}

\begin{verbatim}
> 7 3 <
f
\end{verbatim}

\begin{description}
\item[\texttt{> ( x y -- t/f )}] liefert als Ergebnis des Vergleichs \verb|x|$>$\verb|y| entweder \verb|t| oder \verb|f| zurück.
\end{description}

\begin{verbatim}
> 7 3 >
t
\end{verbatim}

\begin{description}
\item[\texttt{integer? ( x -- t/f )}] testet, ob das Wort \verb|x| eine Ganzzahl (\emph{integer}) repräsentiert, und liefert als Ergebnis entweder \verb|t| oder \verb|f| zurück.
\end{description}

\begin{verbatim}
> -7 integer?
t
> x integer?
f
\end{verbatim}

Hinweis: Alle Wörter zur Arithmetik sind optional und können durch Consize-Programme in der Prelude vollständig ersetzt werden. Sie sind lediglich aus Performanzgründen in der Consize-VM enthalten. Die Referenzimplementierung von Consize rechnet mit Ganzzahlen beliebiger Größe. Notwendig ist jedoch lediglich die Unterstützung von Ganzzahlen mit mindestens 16~Bit Genauigkeit (\href{http://de.wikipedia.org/wiki/Integer\_(Datentyp)}{Integer}), d.h.\ mit einem Wertebereich von $-32.768$ bis $+32.767$.
% Für Berechnungen mit \verb|current-time-millis| sind jedoch mindestens 32~Bit erforderlich.

%\section{Extras: \texttt{current-time-millis}, \texttt{operating-system}}
%\label{Sec:Core.Extras}

%Die zwei Wörter \verb|current-time-millis| und \verb|operating-system| erlauben einerseits z.B.\ die Messung der Laufzeit von Programmen oder die Initialisierung von Zufallsgeneratoren und andererseits z.B.\ den korrekten Umgang mit Zeilenumbrüchen je nach Betriebssystem.

%\begin{description}
%\item[\texttt{current-time-millis ( -- wrd )}] liefert als Wort die Anzahl der \href{http://de.wikipedia.org/wiki/Millisekunde#Abgeleitete\_Ma.C3.9Feinheiten}{Millisekunden} zurück, die seit dem 1. Januar 1970 (\href{http://de.wikipedia.org/wiki/UTC}{UTC}, Universal Time Coordinated), der so genannten \href{http://de.wikipedia.org/wiki/Unixzeit}{Unixzeit}, verstrichen sind.
%\end{description}

%Natürlich hängt die beispielhafte Ausgabe von Ihrer aktuellen Zeit ab.

%\begin{verbatim}
%> clear current-time-millis
%1347630655230
%\end{verbatim}

%\begin{description}
%\item[\texttt{operating-system ( -- wrd )}] gibt als Wort das verwendete \href{http://de.wikipedia.org/wiki/Betriebssystem}{Betriebssystem} zurück, unter dem Consize läuft. Das Wort kann Leerzeichen im Namen enthalten.
%\end{description}

%Im Beispiel läuft Consize unter dem Betriebssystem Windows 7.

%\begin{verbatim}
%> clear operating-system
%Windows 7
%\end{verbatim}

%Hinweis: Die Wörter \verb|current-time-millis| und \verb|operating-system| sind optional. Man kann, wenn man möchte, Laufzeitmessungen von Programmen auch durch die Anzahl der Aufrufe von \verb|stepcc| vornehmen.

\section{Zum Start: \texttt{load}, \texttt{call}, \texttt{run}}
\label{sec:core.start}

Mit dem Aufruf von Consize ist über die Kommandozeile als Argument ein Consize-Programm als Zeichenkette zu übergeben. Angenommen, diese Zeichenkette werde durch das Wort \verb|<args>| repräsentiert, so entspricht die Semantik des Programmstarts der Wortfolge

\begin{verbatim}
[ ] <args> uncomment tokenize get-dict func apply
\end{verbatim}

Mit der Beendigung von Consize wird der aktuelle Datastack auf dem Bildschirm ausgegeben. Die Ausgabe und die Notation ist ab\-häng\-ig von der gewählten Implementierungssprache von Consize.

Zum Programmstart stehen alle bisher erwähnten Wörter der Consize-VM im Wörterbuch bereit inklusive der folgenden Wörter, die es erleichtern, ein Programm wie z.B.\ die Prelude aufzurufen und zu starten.

\begin{description}
\item[\texttt{load ( source -- [ \& itms ] )}] liest ein Consize-Programm aus der gegebenen Quelle, typischerweise aus einer Datei, entfernt Kommentare und zerlegt den Input in Wörter und gibt eine Sequenz aus Wörtern zurück. \verb|load| ist in der Consize-VM wie folgt definiert:
\begin{verbatim}
: load ( source -- [ & itms ] ) slurp uncomment tokenize ;
\end{verbatim}
\end{description}

\begin{description}
\item[\texttt{call ( [ quot \& ds ] cs -- ds quot cs concat )}] nimmt eine Quotierung vom Datastack und konkateniert sie mit dem Callstack. 
\begin{verbatim}
: call ( [ quot & ds ] cs -- ds quot cs concat )
  [ swap dup pop swap top rot concat continue ] call/cc ;
\end{verbatim}
\end{description}

Der Aufruf einer über das Wörterbuch assoziierten Quotierung, einer sogenannten "`benamten"' Quotierung, ist über den Mechanismus von \verb|stepcc| geregelt. Der Aufruf einer nicht-benamten, anonymen Quotierung ist mit \verb|call| möglich.

\begin{description}
\item[\texttt{run ( source -- ... )}] liest ein Consize-Programm aus der gegebenen Quelle und führt das Programm aus.
\begin{verbatim}
: run ( source -- ... ) load call ;
\end{verbatim}
\end{description}

\attention Beim Start von Consize sind die Meta-Wörter \verb|read-word|, \verb|read-mapping| und \verb|error| nicht definiert! Damit fehlt Consize das Wissen, wie es mit unbekannten Wörtern, Mappings und Fehlersituationen umgehen soll. Die Bedeutung dieser Wörter ist von der Programmiererin bzw. dem Programmierer festzulegen.

\section{Referenzimplementierung}
\label{Sec:Referenzimplementierung}

Für Consize liegt eine Referenzimplementierung in der funktionalen Sprache \href{http://clojure.org/}{Clojure} vor, die die Consize-VM komplett umsetzt. Das Clojure-Programm ist weniger als 150 Programmzeilen lang! Es läuft unter der \href{http://de.wikipedia.org/wiki/Java\_Virtual\_Machine}{Java Virtual Machine} (JVM). Die Clojure-Implementierung ist im Zweifel der freisprachlichen Spezifikation vorzuziehen -- allerdings ist dafür ein Verständnis der Sprache Clojure erforderlich.

Alternative Implementierungen der Consize-VM müssen das Verhalten der Referenzimplementierung nachbilden, wenn sie sich als "`Consize-VM"' bezeichnen wollen; ausgenommen ist das Wort \verb|identity?|.
% Als Basis der Verhaltensgleichheit können die Test-Suites für die Consize-VM und die Prelude herangezogen werden.

Optionale Wörter der Consize-VM müssen, sofern sie nicht Teil einer Consize-Implementierung sind, in einer angepassten Prelude bereitgestellt werden.
%Von dieser Regelung ausgenommen sind die Wörter aus Kap.~\ref{Sec:Core.Extras}.

